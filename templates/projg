#!/usr/bin/env python3
"""Project git management script"""
import argparse
import asyncio
import json
import os
import sys
import shutil
import subprocess
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Union

class DocSourceManager:
    def __init__(self):
        self.config_path = Path(".projg")
        self.config = self.load_config()
        self.semaphore = asyncio.Semaphore(5)

    def load_config(self) -> Dict:
        """Load .projg configuration file"""
        if not self.config_path.exists():
            return {
                "docs_base_path": "~/.projg/docs",
                "documentation_sources": [],
                "project_name": "",
                "repo_org": ""
            }
        return json.loads(self.config_path.read_text())

    def expand_path(self, path: str) -> str:
        """Expand environment variables and ~ in path"""
        return os.path.expandvars(os.path.expanduser(path))

    async def clone_doc_repo(self, repo: Dict) -> bool:
        """Clone a documentation repository"""
        try:
            repo_url = repo["url"]
            tag = repo.get("tag", "main")
            repo_name = repo_url.split("/")[-1].replace(".git", "")
            base_path = self.expand_path(self.config["docs_base_path"])
            repo_path = Path(base_path) / repo_name

            if not repo_path.parent.exists():
                repo_path.parent.mkdir(parents=True, exist_ok=True)

            async with self.semaphore:
                if not repo_path.exists():
                    # Clone with --no-checkout for efficiency
                    proc = await asyncio.create_subprocess_exec(
                        "git", "clone", "--no-checkout", repo_url,
                        str(repo_path),
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    await proc.communicate()

                # Checkout specific tag
                proc = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_path), "fetch", "origin", tag,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await proc.communicate()

                proc = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_path), "checkout", tag,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await proc.communicate()

                return True
        except Exception as e:
            print(f"Error cloning {repo_url}: {str(e)}", file=sys.stderr)
            return False

    async def process_doc_sources(self) -> None:
        """Process all documentation sources"""
        tasks = []
        for source in self.config["documentation_sources"]:
            tasks.append(self.clone_doc_repo(source))
        
        results = await asyncio.gather(*tasks)
        failed = len([r for r in results if not r])
        if failed:
            print(f"Warning: {failed} documentation source(s) failed to clone", file=sys.stderr)

class ProjectInitializer:
    def __init__(self):
        self.config_path = Path(".projg")
        if not self.config_path.exists():
            print("❌ No .projg configuration file found")
            sys.exit(1)
        
        config = json.loads(self.config_path.read_text())
        self.project_name = config.get("project_name")
        self.repo_org = config.get("repo_org")
        self.repositories = config.get("repositories", [])
        
        if not all([self.project_name, self.repo_org, self.repositories]):
            print("❌ Missing required configuration in .projg file")
            sys.exit(1)
            
        self.base_dir = Path("..").resolve()
        self.semaphore = asyncio.Semaphore(5)
        self.doc_manager = DocSourceManager()

    async def run(self, nuke: bool = False) -> None:
        """Run initialization or nuke operation"""
        if nuke:
            await self.nuke_repositories()
        else:
            await self.init_repositories()
            # Process doc sources after repo initialization
            await self.doc_manager.process_doc_sources()

    # ...rest of ProjectInitializer methods remain unchanged...

async def handle_git_operations(initializer: ProjectInitializer, args) -> None:
    """Handle git operations based on command line arguments"""
    doc_manager = DocSourceManager()
    
    if args.command == "init":
        await doc_manager.process_doc_sources()
        # ... rest of init handling ...
    elif args.command == "nuke":
        # Do not remove documentation sources during nuke
        # ... rest of nuke handling ...

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Project git management")
    subparsers = parser.add_subparsers(dest="command")
    
    init_parser = subparsers.add_parser("init", help="Initialize project")
    nuke_parser = subparsers.add_parser("nuke", help="Remove project files")

    args = parser.parse_args()
    if not args.command:
        parser.print_help()
        sys.exit(1)

    asyncio.run(handle_git_operations(ProjectInitializer(), args))

if __name__ == "__main__":
    main()