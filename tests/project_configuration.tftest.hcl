// Project configuration test file focusing on project settings inheritance and cross-repository configuration
mock_provider "github" {
  source = "./tests/mocks"
}

variables {
  project_name = "test-config" 
  repo_org     = "test-org"
  github_pro_enabled = false
  project_prompt = "Create a microservices project with shared infrastructure"
}

run "validate_project_settings_inheritance" {
  command = plan

  variables {
    // Base project settings that should be inherited
    base_repository = {
      name = "inheritance-test-base"
      description = "Test project for multi-repository configuration"
      visibility = "public"  // Required for GitHub Free tier
      has_issues = true
      has_wiki = false
      delete_branch_on_merge = true
      allow_squash_merge = true
      allow_merge_commit = false
      allow_rebase_merge = false
    }

    repositories = [
      {
        name = "inheritance-test-service-a"
        description = "Service A repository"
        // Inherits all other settings from base_repository
      },
      {
        name = "inheritance-test-service-b"
        description = "Service B repository"
        has_wiki = true  // Override base setting
      }
    ]

    project_name = "test-config"
    repo_org = "test-org"
    project_prompt = "Create a microservices project with shared infrastructure"
  }

  // Update assertions to use the static names
  assert {
    condition = !output.project_repos["inheritance-test-service-a"].has_wiki
    error_message = "service-a should inherit has_wiki=false from base repository"
  }

  assert {
    condition = output.project_repos["inheritance-test-service-a"].delete_branch_on_merge
    error_message = "service-a should inherit delete_branch_on_merge=true from base repository"
  }

  assert {
    condition = output.project_repos["inheritance-test-service-b"].has_wiki
    error_message = "service-b should override has_wiki to true"
  }
}

run "validate_cross_repository_configurations" {
  command = plan

  variables {
    base_repository = {
      name = "cross-repo-test-base"
      description = "Test project for multi-repository configuration"
      visibility = "public"
    }

    repositories = [
      {
        name = "cross-repo-test-service-a"
        description = "Service A repository"
        dependencies = ["cross-repo-test-service-b"]
        environments = ["dev", "prod"]
      },
      {
        name = "cross-repo-test-service-b"
        description = "Service B repository"
        dependencies = []
        environments = ["dev", "prod"]
      }
    ]

    // Project-wide development environment settings
    development_container = {
      base_image = "ubuntu:22.04"
      install_tools = ["git", "curl", "jq"]
      vs_code_extensions = ["GitLens"]
    }
  }

  // Verify dependencies are properly configured
  assert {
    condition = contains(output.development_configuration.dependencies["cross-repo-test-service-a"], "cross-repo-test-service-b")
    error_message = "service-a should depend on service-b"
  }

  // Verify development environment is consistent
  assert {
    condition = alltrue([
      for repo in var.repositories :
      contains(keys(module.repository_files[repo.name].files), ".devcontainer/devcontainer.json")
    ])
    error_message = "All repositories should have consistent devcontainer configuration"
  }

  // Verify project-wide tool configuration is applied
  assert {
    condition = alltrue([
      for repo in var.repositories :
      contains(jsondecode(module.repository_files[repo.name].files[".devcontainer/devcontainer.json"].content).customizations.vscode.extensions, "eamodio.gitlens")
    ])
    error_message = "All repositories should have consistent VS Code extensions"
  }

  // Verify environments are properly configured
  assert {
    condition = alltrue([
      for repo in var.repositories :
      length(setintersection(output.development_configuration.deployment[repo.name].environments, ["dev", "prod"])) == 2
    ])
    error_message = "All repositories should have dev and prod environments configured"
  }
}

run "validate_project_prompt_configuration" {
  command = plan

  variables {
    base_repository = {
      name = "prompt-test-base"
      description = "Test project for multi-repository configuration"
      visibility = "public"
    }

    // Test prompt-based configuration generation
    // The configuration generated by project_prompt should create these repositories
    repositories = [
      {
        name = "prompt-test-frontend"
        description = "Frontend service using Node.js"
        tech_stack = "nodejs"
      },
      {
        name = "prompt-test-backend"
        description = "Backend API using Python"
        tech_stack = "python"
      }
    ]
  }

  // Verify tech stack specific configurations are applied
  assert {
    condition = contains(keys(module.repository_files["prompt-test-frontend"].files), "package.json")
    error_message = "Frontend repository should have Node.js configuration"
  }

  assert {
    condition = contains(keys(module.repository_files["prompt-test-backend"].files), "requirements.txt")
    error_message = "Backend repository should have Python configuration"
  }

  // Verify CI/CD workflows are created
  assert {
    condition = alltrue([
      for repo in var.repositories :
      contains(keys(module.repository_files[repo.name].files), ".github/workflows/ci.yml")
    ])
    error_message = "All repositories should have CI workflow configured"
  }
}

# Cleanup test resources
run "cleanup" {
  command = plan

  variables {
    base_repository = {
      name = "test-config"
      visibility = "public"
      delete_on_destroy = true
    }
    repositories = []
  }
}

# Verify cleanup was successful
run "verify_cleanup" {
  command = plan

  variables {
    base_repository = {
      name = "test-config"
      visibility = "public"
    }
  }

  expect_failures = [
    data.github_repository.base_repo
  ]
}